import { Sandbox as Sandbox$1, SandboxOpts as SandboxOpts$1, CommandResult } from 'e2b';
export * from 'e2b';

interface CursorPosition {
    x: number;
    y: number;
}
interface ScreenSize {
    width: number;
    height: number;
}
/**
 * Configuration options for the Sandbox environment.
 * @interface SandboxOpts
 * @extends {SandboxOptsBase}
 */
interface SandboxOpts extends SandboxOpts$1 {
    /**
     * The screen resolution in pixels, specified as [width, height].
     * @type {[number, number]}
     */
    resolution?: [number, number];
    /**
     * Dots per inch (DPI) setting for the display.
     * @type {number}
     */
    dpi?: number;
    /**
     * Display identifier.
     * @type {string}
     */
    display?: string;
}
declare class Sandbox extends Sandbox$1 {
    protected static readonly defaultTemplate: string;
    private lastXfce4Pid;
    display: string;
    stream: VNCServer;
    /**
     * Use {@link Sandbox.create} to create a new Sandbox instead.
     *
     * @hidden
     * @hide
     * @internal
     * @access protected
     */
    constructor(opts: Omit<SandboxOpts, 'timeoutMs' | 'metadata'> & {
        sandboxId: string;
        envdVersion?: string;
    });
    /**
     * Create a new sandbox from the default `desktop` sandbox template.
     *
     * @param opts connection options.
     *
     * @returns sandbox instance for the new sandbox.
     *
     * @example
     * ```ts
     * const sandbox = await Sandbox.create()
     * ```
     * @constructs Sandbox
     */
    static create<S extends typeof Sandbox>(this: S, opts?: SandboxOpts): Promise<InstanceType<S>>;
    /**
     * Create a new sandbox from the specified sandbox template.
     *
     * @param template sandbox template name or ID.
     * @param opts connection options.
     *
     * @returns sandbox instance for the new sandbox.
     *
     * @example
     * ```ts
     * const sandbox = await Sandbox.create('<template-name-or-id>')
     * ```
     * @constructs Sandbox
     */
    static create<S extends typeof Sandbox>(this: S, template: string, opts?: SandboxOpts): Promise<InstanceType<S>>;
    /**
     * Wait for a command to return a specific result.
     * @param cmd - The command to run.
     * @param onResult - The function to check the result of the command.
     * @param timeout - The maximum time to wait for the command to return the result.
     * @param interval - The interval to wait between checks.
     * @returns `true` if the command returned the result within the timeout, otherwise `false`.
     */
    waitAndVerify(cmd: string, onResult: (result: CommandResult) => boolean, timeout?: number, interval?: number): Promise<boolean>;
    /**
     * Start xfce4 session if logged out or not running.
     */
    private startXfce4;
    /**
     * Take a screenshot and save it to the given name.
     * @param format - The format of the screenshot.
     * @returns A Uint8Array bytes representation of the screenshot.
     */
    screenshot(): Promise<Uint8Array>;
    /**
     * Take a screenshot and save it to the given name.
     * @param format - The format of the screenshot.
     * @returns A Uint8Array bytes representation of the screenshot.
     */
    screenshot(format: 'bytes'): Promise<Uint8Array>;
    /**
     * Take a screenshot and save it to the given name.
     * @returns A Blob representation of the screenshot.
     */
    screenshot(format: 'blob'): Promise<Blob>;
    /**
     * Take a screenshot and save it to the given name.
     * @returns A ReadableStream of bytes representation of the screenshot.
     */
    screenshot(format: 'stream'): Promise<ReadableStream<Uint8Array>>;
    /**
     * Left click on the mouse position.
     */
    leftClick(x?: number, y?: number): Promise<void>;
    /**
     * Double left click on the mouse position.
     */
    doubleClick(x?: number, y?: number): Promise<void>;
    /**
     * Right click on the mouse position.
     */
    rightClick(x?: number, y?: number): Promise<void>;
    /**
     * Middle click on the mouse position.
     */
    middleClick(x?: number, y?: number): Promise<void>;
    /**
     * Scroll the mouse wheel by the given amount.
     * @param direction - The direction to scroll. Can be "up" or "down".
     * @param amount - The amount to scroll.
     */
    scroll(direction?: 'up' | 'down', amount?: number): Promise<void>;
    /**
     * Move the mouse to the given coordinates.
     * @param x - The x coordinate.
     * @param y - The y coordinate.
     */
    moveMouse(x: number, y: number): Promise<void>;
    /**
     * Press the mouse button.
     */
    mousePress(button?: 'left' | 'right' | 'middle'): Promise<void>;
    /**
     * Release the mouse button.
     */
    mouseRelease(button?: 'left' | 'right' | 'middle'): Promise<void>;
    /**
     * Get the current cursor position.
     * @returns A object with the x and y coordinates
     * @throws Error if cursor position cannot be determined
     */
    getCursorPosition(): Promise<CursorPosition>;
    /**
     * Get the current screen size.
     * @returns An {@link ScreenSize} object
     * @throws Error if screen size cannot be determined
     */
    getScreenSize(): Promise<ScreenSize>;
    private breakIntoChunks;
    private quoteString;
    /**
     * Write the given text at the current cursor position.
     * @param text - The text to write.
     * @param options - An object containing the chunk size and delay between each chunk of text.
     * @param options.chunkSize - The size of each chunk of text to write. Default is 25 characters.
     * @param options.delayInMs - The delay between each chunk of text. Default is 75 ms.
     */
    write(text: string, options?: {
        chunkSize: number;
        delayInMs: number;
    }): Promise<void>;
    /**
     * Press a key.
     * @param key - The key to press (e.g. "enter", "space", "backspace", etc.). Can be a single key or an array of keys.
     */
    press(key: string | string[]): Promise<void>;
    /**
     * Drag the mouse from the given position to the given position.
     * @param from - The starting position.
     * @param to - The ending position.
     */
    drag([x1, y1]: [number, number], [x2, y2]: [number, number]): Promise<void>;
    /**
     * Wait for the given amount of time.
     * @param ms - The amount of time to wait in milliseconds.
     */
    wait(ms: number): Promise<void>;
    /**
     * Open a file or a URL in the default application.
     * @param fileOrUrl - The file or URL to open.
     */
    open(fileOrUrl: string): Promise<void>;
    /**
     * Get the current window ID.
     * @returns The ID of the current window.
     */
    getCurrentWindowId(): Promise<string>;
    /**
     * Get the window ID of the window with the given title.
     * @param title - The title of the window.
     * @returns The ID of the window.
     */
    getApplicationWindows(application: string): Promise<string[]>;
    /**
     * Get the title of the window with the given ID.
     * @param windowId - The ID of the window.
     * @returns The title of the window.
     */
    getWindowTitle(windowId: string): Promise<string>;
    /**
     * Launch an application.
     * @param application - The application to launch.
     * @param uri - The URI to open in the application.
     */
    launch(application: string, uri?: string): Promise<void>;
}
interface VNCServerOptions {
    vncPort?: number;
    port?: number;
    requireAuth?: boolean;
    windowId?: string;
}
interface UrlOptions {
    autoConnect?: boolean;
    viewOnly?: boolean;
    resize?: 'off' | 'scale' | 'remote';
    authKey?: string;
}
declare class VNCServer {
    private vncPort;
    private port;
    private novncAuthEnabled;
    private url;
    private novncHandle;
    private password;
    private readonly novncCommand;
    private readonly desktop;
    constructor(desktop: Sandbox);
    getAuthKey(): string;
    /**
     * Set the VNC command to start the VNC server.
     */
    private getVNCCommand;
    private waitForPort;
    /**
     * Check if the VNC server is running.
     * @returns Whether the VNC server is running.
     */
    private checkVNCRunning;
    /**
     * Get the URL to a web page with a stream of the desktop sandbox.
     * @param autoConnect - Whether to automatically connect to the server after opening the URL.
     * @param viewOnly - Whether to prevent user interaction through the client.
     * @param resize - Whether to resize the view when the window resizes.
     * @param authKey - The password to use to connect to the server.
     * @returns The URL to connect to the VNC server.
     */
    getUrl({ autoConnect, viewOnly, resize, authKey, }?: UrlOptions): string;
    /**
     * Start the VNC server.
     */
    start(opts?: VNCServerOptions): Promise<void>;
    /**
     * Stop the VNC server.
     */
    stop(): Promise<void>;
}

export { Sandbox };
